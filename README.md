# introduction
## 設計原則
①アプリケーション内の変化する部分を特定し、不変な部分と分離する  
目的：変わる部分を見つけて、他の部分から分離することで、変更の影響を局所化する  
②実装に対してではなく、インターフェースに対してプログラミングする  
目的：具体的なクラス（実装）に依存するのではなく、共通のインターフェースや抽象クラスに依存することで、柔軟な設計が可能  
③継承よりコンポジションの方が好ましい  
目的：クラスを拡張するために継承（extends）を多用するのではなく、機能を持ったオブジェクトを「持つ」ようにして再利用する（コンポジション）方が柔軟になる  

## コンポジションの必要性  
あとからの仕様変更・拡張に強い、壊れにくいコードを作るため  

### 抽象化  
意味：本質的な特徴だけを抜き出して、複雑さを隠すこと  
意識すべきこと：利用者に必要な操作だけを提供し、余計な情報は隠す  
```
public interface Animal {
    void speak(); // 何を話すかは具体的な実装に任せる
}
```
### カプセル化  
意味：データとそれを操作するメソッドを一体化し、外部から勝手に変更されないようにすること  
意識すべきこと：データは原則privateにし、必要に応じて公開  
```
public class User {
    private String name;

    public String getName() { return name; }
    public void setName(String name) {
        if (name != null && !name.isBlank()) this.name = name;
    }
}
```
### 多様性  
意味：同じメソッドでも、オンジェクトの型によって異なる振る舞いができること  
意識すべきこと：共通インターフェースや継承元クラスで定義したメソッドを具体クラスごとにオーバーライド  
実行時に適切な動作に分岐できるので、コードの再利用性・柔軟性が高まる  
```
Animal a = new Dog();
a.speak(); // ワンと出力される

a = new Cat();
a.speak(); // ニャーと出力される
```
### 継承  
意味：既存のクラスを拡張して、新しいクラスを作ること  
意識すべきこと：再利用性は高まるが、過剰な継承は密結合・保守困難のもとになる
```
public class Vehicle {
    public void move() { System.out.println("Moving..."); }
}

public class Car extends Vehicle {
    public void honk() { System.out.println("Beep!"); }
}
```  

# observer
## Oberverパターンとは  
あるオブジェクトの状態が変化すると、そのオブジェクトに依存している全てのオブジェクトに自動的に通知され、更新されるようにするという、オブジェクト感の1対多の依存関係が定義されている  
## 設計原則  
①相互にやり取りを行うオブジェクト間には、疎結合設計を使う  
## Observerパターンのメリット  
- 疎結合になる（Observerそれぞれが値を管理する必要がない。Subjectの参照で済む）
- 動的にオブサーバーを追加削除できる
- 再利用性が高い
- 状態変更を自動で伝播
## Observerパターンのデメリット
- 通知の順序やタイミングに依存する可能性
- デバッグが難しくなる
- 循環参照や無限ループの危険
- パフォーマンスの懸念

## Observerパターンを使うべきか判断するための思考の流れ  
1. 何かが変わった時に、誰に伝える必要があるか？  
主役は何か？  
変化を「見張る」必要があるのは誰か  
モデルが更新された時、ビューーを自動更新したい    
「状態変化右複数への通知」が自然に出てくるなら候補    
2. 通知先が固定か動的かを確認  
通知する相手が固定 → 単純なコールバックでOKかも  
通知する相手が動的（途中で追加・削除される）→ Observerパターンの出番  
3. 「依存の方向性を一方向に保てるか？」を意識する  
Subject（通知元）は Observer（通知先）を知らなくていい構造にできるのが理想  
→ これにより「疎結合」が実現できる  